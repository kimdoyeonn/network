- 웹 캐시는 레이턴시와 네트워크 트래픽을 줄여줌으로써 리소스를 보여주는 데에 필요한 시간을 줄여줍니다.
- HTTP 캐시를 활용하면 웹 사이트가 좀 더 빠르게 반응하도록 만들 수 있음

## 다른 종류의 캐시
- 캐싱: 주어진 리소스의 복사본을 저장하고 있다가 요청 시에 그것을 제공하는 기술
- 웹 캐시가 자신의 저장소 내에 요청된 리소스를 가지고 있다면, 요청을 가로채 원래의 서버로부터 리소스를 다시 다운로드하는 대신 리소스의 복사본을 반환
	- 모든 클라이언트에 서비스할 필요가 없어지므로 서버의 부하를 완화
	- 원래 서버에 비해 클라이언트에 더 가까이 있으므로 성능 향상 => 리소스를 회신하는데 더 적은 시간이 들게 됨
- 모든 리소스가 영원히 변하지 않는 것은 아니므로 리소스가 변하기 전까지만 캐싱하고 변한 이후에는 더이상 캐싱하지 않는 것이 중요

캐시는 크게 두 가지 분류로 나눌 수 있음
- private: 한 명의 사용자만 사용하는 캐시
- shared: 한 명 이상의 사용자가 재사용할 수 있도록 응답을 저장하는 캐시
- 그 외에는 브라우저 캐시, 프록시 캐시, 게이트웨이 캐시, CDN, 리버스 프록시 캐시, 로드 밸랜서 등

#### private 브라우저 캐시
- 단일 사용자가 전용으로 사용
- 사용자에 의해 HTTP를 통해 다운로드된 모든 문서들을 가지고 있음
- 서버에 대한 추가적인 요청 없이 방문했던 문서들을 사용할 수 있도록 해줌(뒤로가기, 앞으로 가기, 저장, 소스로 보기 등에 사용)
- 캐시된 컨텐츠의 오프라인 브라우징을 개선

#### shared 프록시 캐시
- 한 명 이상의 사용자에 의해 재사용되는 응답을 저장한 캐시
- ISP(Internet Service Provider)는 많은 사용자들을 서비스하기 위해 지역 네트워크 기반의 일부분으로서 웹 프록시를 설치해두기도 한다. 그 덕분에 조회가 많이 되는 리소스는 여러번 재사용되어 네트워크 트래픽과 레이턴시를 줄여줌

## 캐싱 동작의 대상
- 일반적으로 GET에 대한 응답만 캐싱하며, 다른 메서드들은 제외됨
- 기본 캐시 키(primary cache key): 요청 매서드 + URI

## 캐싱 제어
#### `Cache-Control` 헤더
- Cache-Control HTTP/1.1 기본 헤더 필드는 요청과 응답 양측 모두에 있어 캐싱 매커니즘을 위한 디렉티브를 지정하는데 사용
- 이 헤더필드가 제공하는 여러 디렉티브들로 캐싱 정책을 정의하고자 한다면 이 헤더를 사용

##### 캐시하지 않음
```
Cache-Control: no-store
```
- 클라이언트 요청 혹은 서버 응답에 관해서 어떤 것도 저장해서는 안됨
- 요청은 서버 측으로 전송되고 전체 응답은 매번 다운로드

##### 캐시하지만 재검증
```
Cache-Control: no-cache
```
- 캐시된 복사본을 사용자에게 릴리즈하기 전에 유효성 확인을 위해 서버로 요청을 보냄

##### private 캐시와 shared 캐시
```
Cache-Control: private
Cache-Control: public
```
- `public` 은 어떤 응답이 어떤 캐시에 의해서든 캐시되어도 된다.
	- HTTP 인증, 캐시 가능하지 않은 응답 상태코드를 지닌 페이지가 캐시되어야할 경우에 유용
- `private` : 공유 캐시에 의해 저장되어서는 안됨
	- private 브라우저 캐시는 이런 경에 응답을 저장

##### 만료
```
Cache-Control: max-age=31536000
```
- `max-age=<seconds>` : 리소스가 유효하다고 판단되는 최대 시간
- 요청 시간에 상대적이며, `Expires`가 설정되어 있더라도 우선으로 적용됨
- 이미지, CSS, JavaScript 파일 같이 변경되지 않는 파일은 극단적으로 길게 설정하여 캐싱할 수 있음

##### 검증
```
Cache-Control: must-revalidate
```
- 오래된 리소스를 사용하기 전에 그 상태를 확인하고 만료되었으면 사용하지 않음

#### `Pragma` 헤더
- HTTP/1.0 헤더
- `Pragma: no-cache`는 캐시가 검증을 위해 원래 서버로 요청을 보내도록 강제한다는 점에서 `Cache-Control: no-cache`와 유사하지만 HTTP 응답에 명세되지 않으므로 `Cache-Control`헤더보다 신뢰성이 떨어짐
- HTTP/1.1 헤더가 없는 HTTP/1.0 클라이언트와의 하위 호환성을 위한 경우에만 사용


## 유효성(Freshness)
- 리소스가 캐시 내에 저장되고 나면, 이론적으로는 영원히 캐시에 의해 서비스될 수 있음
- 캐시 축출(cache eviction): 캐시 공간 확보를 위해 저장된 데이터를 주기적으로 스토리지에서 제거
- 유효(fresh) -> 실효(stale)
- 축출 알고리즘은 대개 실효된 리소스보다 유효한 리소스에 우선권을 줍니다.
- 캐시가 실효된 리소스에 대한 요청을 받은 경우, 이 리소스가 실제로 아직 유효한지 아닌지를 확인하기 위해 `If-None-Match`와 함께 요청을 전달, 만약 유효하다면 서버는 요청된 리소스 본문 대신에 304(Not Modified) 헤더를 돌려보내 대역폭을 절약
- 실효된 리소스는 무작정 축출되거나 무시되는 것이 아니라 아직 유효한지 확인함!
	- `Cache-Control: max-age=N`: 유효수명은 N
	- `Expires` 가 있다면 거기서 `Date` 헤더의 값을 뺸 결과가 유효수명


#### 유효성 검사 휴리스틱
- 원 서버가 명시적으로 유효성을 지정하지 않았다면 휴리스틱으로 유효 기간을 추정
- `Last-Modified` 헤더가 있다면 캐시의 유효 수명은 `Date` 헤더 값에서 `Last-Modified` 헤더 값을 뺀 값을 10으로 나눈 결과
- 만료 시간 계산 방법
```
expirationTime = responseTime(브라우저가 응답을 수신한 시간) + freshnessLifetime - currentAge
```

